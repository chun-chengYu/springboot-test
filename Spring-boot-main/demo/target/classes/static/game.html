<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>éŠæˆ²æŒ‡ä»¤ä»‹é¢ - å‹‡è€…å†’éšªç‰©èª</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 2em; background-color: #f0f2f5; color: #333; display: flex; flex-direction: column; align-items: center; }
        .container { width: 100%; max-width: 700px; background-color: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        h2 { text-align: center; color: #333; margin-bottom: 1.5em; }
        h3 { color: #555; margin-top: 1em; margin-bottom: 0.8em; border-bottom: 1px solid #eee; padding-bottom: 0.3em;}

        #output { margin-top: 1em; background: #f8f9fa; padding: 1em; min-height: 150px; max-height: 300px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 4px; line-height: 1.6; }
        #command, #playerNameInput, #playerIdToLoad { width: calc(100% - 22px); padding: 10px; margin-bottom:10px; border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; font-size: 1em;}

        .button-group { margin-top: 1em; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        button { padding: 10px 18px; border: none; border-radius: 5px; cursor: pointer; font-size: 0.95em; transition: background-color 0.2s ease-in-out, transform 0.1s ease; }
        button:hover { transform: translateY(-1px); }
        button:active { transform: translateY(0px); }

        button[type="submit"], #createCharacterButton, #confirmLoadButton { background-color: #007bff; color: white; }
        button[type="submit"]:hover, #createCharacterButton:hover, #confirmLoadButton:hover { background-color: #0056b3; }

        #saveButton { background-color: #28a745; color: white;}
        #saveButton:hover { background-color: #1e7e34; }

        #loadButton, #showLoadGameButton { background-color: #ffc107; color: #212529;}
        #loadButton:hover, #showLoadGameButton:hover { background-color: #e0a800;}

        #helpButton { background-color: #17a2b8; color: white;}
        #helpButton:hover { background-color: #117a8b;}

        #newGameButton, #backToCreateButton { background-color: #6c757d; color: white; }
        #newGameButton:hover, #backToCreateButton:hover { background-color: #545b62; }


        .status-bar { background: #f8f9fa; border: 1px solid #e0e0e0; padding: 12px; border-radius: 4px; margin-bottom: 1.5em; text-align: left; font-size: 0.9em; }
        .status-bar strong {color: #333;}

        .message-log { padding: 8px 12px; border-radius: 4px; margin: 5px 0; font-size: 0.95em; }
        .error { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb;}
        .success { color: #155724; background-color: #d4edda; border: 1px solid #c3e6cb;}
        .info { color: #0c5460; background-color: #d1ecf1; border: 1px solid #bee5eb;}

        #characterCreationSection, #loadGameSection, #gameInterface {
             margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>ğŸ—¡ï¸ æ³¥å·´éŠæˆ²</h2>

        <div id="characterCreationSection">
            <h3>å‰µå»ºæ–°æ³¥å·´</h3>
            <input type="text" id="playerNameInput" placeholder="è«‹è¼¸å…¥ä½ çš„å‹‡è€…å¤§å" required>
            <div class="button-group">
                <button type="button" id="createCharacterButton">âœ¨ é–‹å§‹æ–°å†’éšª</button>
                <button type="button" id="showLoadGameButton">ğŸ“‚ è®€å–å·²æœ‰éŠæˆ²</button>
            </div>
        </div>

        <div id="loadGameSection" style="display: none;">
            <h3>è®€å–éŠæˆ²é€²åº¦</h3>
            <input type="number" id="playerIdToLoad" placeholder="è¼¸å…¥å­˜æª”ID (ä¾‹å¦‚: 1)">
            <div class="button-group">
                <button type="button" id="confirmLoadButton">ğŸ“‚ ç¢ºèªè®€å–</button>
                <button type="button" id="backToCreateButton">â†©ï¸ è¿”å›å‰µå»º</button>
            </div>
        </div>

        <div id="gameInterface" style="display: none;">
            <div class="status-bar">
                <strong>ç©å®¶ç‹€æ…‹:</strong>
                <span id="playerStatus"></span>
            </div>
            <form id="commandForm">
                <input type="text" id="command" placeholder="è¼¸å…¥æŒ‡ä»¤ (è¼¸å…¥ help æŸ¥çœ‹å¹«åŠ©)"
                       autocomplete="off" required>
                <div class="button-group">
                    <button type="submit">ğŸš€ åŸ·è¡ŒæŒ‡ä»¤</button>
                    <button type="button" id="saveButton">ğŸ’¾ ç«‹å³ä¿å­˜</button>
                    <button type="button" id="loadButton">ğŸ”„ é‡æ–°è¼‰å…¥</button>
                    <button type="button" id="helpButton">â“ æŒ‡ä»¤å¹«åŠ©</button>
                    <button type="button" id="newGameButton">â˜ ï¸ æ”¾æ£„é‡ä¾†</button>
                </div>
            </form>
            <div id="output"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let currentPlayer = null;
            let gameState = {
                currentRoom: null,
                monsterHpMap: {}
            };

            const uiSections = {
                creation: document.getElementById('characterCreationSection'),
                load: document.getElementById('loadGameSection'),
                game: document.getElementById('gameInterface')
            };

            const elements = {
                playerNameInput: document.getElementById('playerNameInput'),
                createCharacterButton: document.getElementById('createCharacterButton'),
                showLoadGameButton: document.getElementById('showLoadGameButton'),
                playerIdToLoadInput: document.getElementById('playerIdToLoad'),
                confirmLoadButton: document.getElementById('confirmLoadButton'),
                backToCreateButton: document.getElementById('backToCreateButton'),
                form: document.getElementById('commandForm'),
                commandInput: document.getElementById('command'),
                outputDiv: document.getElementById('output'),
                playerStatus: document.getElementById('playerStatus'),
                saveButton: document.getElementById('saveButton'),
                loadButton: document.getElementById('loadButton'),
                helpButton: document.getElementById('helpButton'),
                newGameButton: document.getElementById('newGameButton')
            };

            // æª¢æŸ¥å…ƒç´ æ˜¯å¦å­˜åœ¨
            for (const key in elements) {
                if (!elements[key]) console.error(`éŒ¯èª¤ï¼šHTML å…ƒç´ æœªæ‰¾åˆ° - ID é æœŸç‚º: ${key}`);
            }
            for (const key in uiSections) {
                if (!uiSections[key]) console.error(`éŒ¯èª¤ï¼šUI å€å¡Šæœªæ‰¾åˆ° - ID é æœŸç‚º: ${key}`);
            }

            function showSection(sectionName) {
                console.log(`[UI] å˜—è©¦é¡¯ç¤ºå€å¡Š: ${sectionName}`);
                Object.values(uiSections).forEach(section => {
                    if (section) section.style.display = 'none';
                });
                if (uiSections[sectionName]) {
                    uiSections[sectionName].style.display = 'block';
                } else {
                    console.error(`[UI] éŒ¯èª¤ï¼šæ‰¾ä¸åˆ°è¦é¡¯ç¤ºçš„å€å¡Š ${sectionName}`);
                }
                if (sectionName !== 'game' && elements.outputDiv) elements.outputDiv.innerHTML = '';
            }

            async function handleAPICall(url, method = 'GET', data = null) {
                const options = { method, headers: { 'Content-Type': 'application/json' } };
                if (data && method !== 'GET') options.body = JSON.stringify(data);
                console.log(`[API] ç™¼é€è«‹æ±‚: ${method} ${url}`, data || '');
                try {
                    const response = await fetch(url, options);
                    let responseData;
                    const contentType = response.headers.get("content-type");
                    if (contentType && contentType.includes("application/json")) {
                        responseData = await response.json();
                    } else {
                        const textResponse = await response.text();
                        if (!response.ok) throw new Error(`ä¼ºæœå™¨éŒ¯èª¤ ${response.status}: ${textResponse.substring(0,100)}`);
                        return { messages: [textResponse || "æ“ä½œæˆåŠŸä½†ç„¡JSONè¿”å›"] };
                    }
                    console.log(`[API] æ”¶åˆ°éŸ¿æ‡‰ (${url}):`, responseData);
                    if (!response.ok) {
                        const errorMsg = responseData?.messages?.join(', ') || responseData?.message || responseData?.error || `ä¼ºæœå™¨éŒ¯èª¤ ${response.status}`;
                        throw new Error(errorMsg);
                    }
                    return responseData;
                } catch (error) {
                    console.error(`[API] è«‹æ±‚ ${method} ${url} å¤±æ•—:`, error);
                    throw error;
                }
            }

            function updateAndDisplayGameData(data, successMessage = null, isNewGameMessage = true) {
                if (data.player) currentPlayer = data.player;
                if (data.gameState) {
                    gameState.currentRoom = data.gameState.currentRoom;
                    gameState.monsterHpMap = data.gameState.monsterHpMap || {};
                }
                updatePlayerStatus();
                if (successMessage) appendMessage(successMessage, 'success');
                if (isNewGameMessage && currentPlayer) {
                    const welcomeType = successMessage?.includes("å‰µå»ºæˆåŠŸ") ? "æ–°éŠæˆ²" : (successMessage?.includes("è®€å–æˆåŠŸ") ? "æ­¡è¿å›ä¾†" : null);
                    if (welcomeType === "æ–°éŠæˆ²") appendMessage(`ğŸ‘¾ [ éŠæˆ²é–‹å§‹ï¼æ­¡è¿å‹‡è€… ${currentPlayer.name}ï¼ ]`, 'info');
                    else if (welcomeType === "æ­¡è¿å›ä¾†") appendMessage(`â†©ï¸ [ æ­¡è¿å›ä¾†ï¼Œå‹‡è€… ${currentPlayer.name}ï¼ ]`, 'info');
                }
            }
            
            if (elements.createCharacterButton) {
                elements.createCharacterButton.addEventListener('click', async () => {
                    console.log('[Event] ã€Œé–‹å§‹æ–°å†’éšªã€æŒ‰éˆ•é»æ“Š');
                    const playerName = elements.playerNameInput.value.trim();
                    if (!playerName) { appendMessage("âŒ è«‹è¼¸å…¥å‹‡è€…åç¨±ï¼", 'error'); return; }
                    appendMessage("ğŸ”„ æ­£åœ¨å‰µå»ºè§’è‰²...", 'info');
                    try {
                        const data = await handleAPICall('/api/player/create', 'POST', { name: playerName });
                        updateAndDisplayGameData(data, `âœ… å‹‡è€… ${data.player.name} å‰µå»ºæˆåŠŸï¼(ID: ${data.player.id})`);
                        showSection('game');
                        await sendCommand("look");
                    } catch (error) { appendMessage(`âŒ è§’è‰²å‰µå»ºå¤±æ•—: ${error.message}`, 'error'); }
                });
            }

            if (elements.showLoadGameButton) elements.showLoadGameButton.addEventListener('click', () => { console.log('[Event] ã€Œè®€å–å·²æœ‰éŠæˆ²ã€æŒ‰éˆ•é»æ“Š'); showSection('load'); });
            if (elements.backToCreateButton) elements.backToCreateButton.addEventListener('click', () => { console.log('[Event] ã€Œè¿”å›å‰µå»ºã€æŒ‰éˆ•é»æ“Š'); showSection('creation'); });

            async function fetchPlayerAndStartGame(playerId) {
                if (!playerId) { appendMessage("âŒ æœªæä¾›ç©å®¶IDã€‚", 'error'); return; }
                appendMessage(`ğŸ”„ æ­£åœ¨è®€å– ID: ${playerId} çš„å­˜æª”...`, 'info');
                try {
                    const data = await handleAPICall(`/api/player/load/${playerId}`); // GETè«‹æ±‚ä¸éœ€è¦body
                    updateAndDisplayGameData(data, `ğŸ“‚ éŠæˆ²è®€å–æˆåŠŸï¼`);
                    showSection('game');
                    await sendCommand("look");
                } catch (error) { appendMessage(`âŒ è®€å–å¤±æ•— (ID: ${playerId}): ${error.message}`, 'error'); }
            }

            if (elements.confirmLoadButton) elements.confirmLoadButton.addEventListener('click', () => { console.log('[Event] ã€Œç¢ºèªè®€å–ã€æŒ‰éˆ•é»æ“Š'); fetchPlayerAndStartGame(elements.playerIdToLoadInput.value.trim()); });
            if (elements.loadButton) elements.loadButton.addEventListener('click', () => {
                console.log('[Event] ã€Œé‡æ–°è¼‰å…¥ã€æŒ‰éˆ•é»æ“Š');
                if (currentPlayer && currentPlayer.id) fetchPlayerAndStartGame(currentPlayer.id);
                else { appendMessage("â„¹ï¸ æ²’æœ‰ç•¶å‰è§’è‰²å¯é‡æ–°è¼‰å…¥ã€‚", 'info'); showSection('load'); }
            });
            
            if (elements.newGameButton) elements.newGameButton.addEventListener('click', () => {
                console.log('[Event] ã€Œæ”¾æ£„é‡ä¾†ã€æŒ‰éˆ•é»æ“Š');
                if (confirm("ç¢ºå®šè¦æ”¾æ£„ç›®å‰é€²åº¦ä¸¦é‡æ–°é–‹å§‹å—ï¼Ÿæœªä¿å­˜çš„æ•¸æ“šå°‡æœƒéºå¤±ï¼")) {
                    currentPlayer = null;
                    gameState = { currentRoom: null, monsterHpMap: {} };
                    if (elements.commandInput) elements.commandInput.value = '';
                    showSection('creation');
                    updatePlayerStatus();
                    appendMessage('ğŸ‘‹ è«‹é‡æ–°å‰µå»ºè§’è‰²æˆ–è®€å–é€²åº¦ã€‚', 'info');
                }
            });

            async function sendCommand(commandText) {
                const cmd = commandText.trim();
                if (!cmd) return;
                if (!currentPlayer || currentPlayer.id == null) { appendMessage("âŒ è«‹å…ˆå‰µå»ºæˆ–åŠ è¼‰è§’è‰²ï¼", 'error'); return; }
                const payload = { input: cmd, playerId: currentPlayer.id }; // ç™¼é€ playerId
                console.log('[Command] ç™¼é€æŒ‡ä»¤:', payload);
                try {
                    const data = await handleAPICall('/api/game/command', 'POST', payload);
                    if (data.messages) data.messages.forEach(msg => appendMessage(msg, msg.toLowerCase().includes("éŒ¯èª¤") || msg.toLowerCase().includes("ç„¡æ•ˆ") || msg.toLowerCase().includes("å¤±æ•—") ? 'error' : 'info'));
                    if (data.player) Object.assign(currentPlayer, data.player);
                    if (data.gameState) {
                        gameState.currentRoom = data.gameState.currentRoom !== undefined ? data.gameState.currentRoom : gameState.currentRoom;
                        gameState.monsterHpMap = data.gameState.monsterHpMap !== undefined ? data.gameState.monsterHpMap : gameState.monsterHpMap;
                    }
                    updatePlayerStatus();
                } catch (error) { appendMessage(`âŒ æŒ‡ä»¤è™•ç†å¤±æ•—: ${error.message}`, 'error'); }
            }

            if (elements.form) elements.form.addEventListener('submit', async (e) => {
                e.preventDefault();
                console.log('[Event] æŒ‡ä»¤è¡¨å–®æäº¤');
                if (elements.commandInput) { await sendCommand(elements.commandInput.value); elements.commandInput.value = ''; }
            });

            if (elements.saveButton) elements.saveButton.addEventListener('click', async () => {
                console.log('[Event] ã€Œç«‹å³ä¿å­˜ã€æŒ‰éˆ•é»æ“Š');
                if (!currentPlayer || currentPlayer.id == null) { appendMessage("âŒ æ²’æœ‰è§’è‰²æ•¸æ“šå¯ä¿å­˜ã€‚", 'error'); return; }
                const saveData = {
                    id: currentPlayer.id,
                    name: currentPlayer.name,
                    hp: currentPlayer.hp,
                    maxHp: currentPlayer.maxHp,
                    attack: currentPlayer.attack,
                    level: currentPlayer.level,
                    skillNames: currentPlayer.skillNames || [],
                    totalDamage: currentPlayer.totalDamage || 0,
                    killCount: currentPlayer.killCount || 0,
                    usedSkills: currentPlayer.usedSkills || [],
                    inventory: currentPlayer.inventory || {},
                    gameState: {
                        currentRoom: gameState.currentRoom,
                        monsterHpMap: gameState.monsterHpMap || {}
                    }
                };
                console.log("æº–å‚™ç™¼é€åˆ° /api/player/save çš„æ•¸æ“š:", JSON.stringify(saveData, null, 2));
                appendMessage("ğŸ”„ æ­£åœ¨ä¿å­˜é€²åº¦...", 'info');
                try {
                    const responseData = await handleAPICall('/api/player/save', 'POST', saveData);
                    if (responseData.player) Object.assign(currentPlayer, responseData.player);
                    if (responseData.gameState) {
                        gameState.currentRoom = responseData.gameState.currentRoom !== undefined ? responseData.gameState.currentRoom : gameState.currentRoom;
                        gameState.monsterHpMap = responseData.gameState.monsterHpMap !== undefined ? responseData.gameState.monsterHpMap : gameState.monsterHpMap;
                    }
                    updatePlayerStatus();
                    appendMessage(`âœ… ä¿å­˜æˆåŠŸï¼ç©å®¶ID: ${currentPlayer.id}`, 'success');
                } catch (error) { appendMessage(`âŒ ä¿å­˜å¤±æ•—: ${error.message}`, 'error'); }
            });

            if (elements.helpButton) elements.helpButton.addEventListener('click', () => {
                console.log('[Event] ã€ŒæŒ‡ä»¤å¹«åŠ©ã€æŒ‰éˆ•é»æ“Š');
                const helpMessages = [ /* ...å¹«åŠ©è¨Šæ¯ä¸è®Š... */ ];
                helpMessages.forEach(msg => appendMessage(msg, 'info'));
            });

            function updatePlayerStatus() {
                if (!elements.playerStatus) { console.warn("[UI] playerStatus å…ƒç´ æœªæ‰¾åˆ°ã€‚"); return; }
                if (currentPlayer && currentPlayer.id != null) {
                    let locationName = "æœªçŸ¥åœ°é»";
                    if(gameState.currentRoom) {
                        const roomMap = {"forest_entrance": "æ£®æ—å…¥å£", "temple_hall": "ç¥æ®¿å¤§å»³"};
                        locationName = roomMap[gameState.currentRoom.toLowerCase()] || gameState.currentRoom;
                    }
                    elements.playerStatus.textContent = `ID: ${currentPlayer.id} | å‹‡è€…: ${currentPlayer.name} | HP: ${currentPlayer.hp}/${currentPlayer.maxHp} | æ”»æ“ŠåŠ›: ${currentPlayer.attack} | ç­‰ç´š: ${currentPlayer.level} | æ“Šæ®º: ${currentPlayer.killCount} | ä½ç½®: ${locationName}`;
                } else {
                    elements.playerStatus.textContent = "è«‹å‰µå»ºæ–°è§’è‰²æˆ–è®€å–å·²æœ‰é€²åº¦ã€‚";
                }
            }

            function appendMessage(text, type = 'info') {
                if (!elements.outputDiv) { console.warn("[UI] outputDiv å…ƒç´ æœªæ‰¾åˆ°ï¼Œç„¡æ³•é™„åŠ è¨Šæ¯:", text); return; }
                const div = document.createElement('div');
                div.className = `message-log ${type}`;
                div.textContent = text;
                while (elements.outputDiv.childNodes.length > 70) {
                    elements.outputDiv.removeChild(elements.outputDiv.firstChild);
                }
                elements.outputDiv.appendChild(div);
                elements.outputDiv.scrollTop = elements.outputDiv.scrollHeight;
            }

            // åˆå§‹åŒ–
            if (uiSections.creation) showSection('creation');
            else console.error("åš´é‡éŒ¯èª¤ï¼šè§’è‰²å‰µå»ºå€å¡Š (characterCreationSection) æœªåœ¨ HTML ä¸­å®šç¾©ï¼");
            updatePlayerStatus();
            appendMessage('ğŸ‘‹ æ­¡è¿ä¾†åˆ°å‹‡è€…å†’éšªç‰©èªï¼è«‹å‰µå»ºæ–°è§’è‰²æˆ–è®€å–å·²æœ‰é€²åº¦é–‹å§‹ä½ çš„æ—…ç¨‹ã€‚', 'info');
        });
    </script>
</body>
</html>
